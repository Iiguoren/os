## 改变bootsect时系统显示
```c
entry _start            ! 告诉编译器从这里开始运行
_start:
    mov ah,#0x03        ! 调用BIOS的10号中断读取光标位置，功能号ah=0x03，bh=0
    xor bh,bh           ! bh设置为0
    int 0x10
    mov cx,#36          ! 要打印的字符串长度为36
    mov bx,#0x0007      ! 要显示的字符属性，0x0007就是表示白底黑字
    mov bp,#msg1        ! 要打印的字符串的起始位置（段内偏移）
    mov ax,#0x07c0      ! 设置es为0x07c0，引导扇区被加载到内存的初始地址是0x7c00，段地址就是0x07c0，es:bp就是字符串的位置。
    mov es,ax       
    mov ax,#0x1301      ! 调用BIOS的10号中断打印字符串，写入字符后, 要移动光标到下一个位置。ah=13表示功能号、al=1表示字符属性使用bl的值、并且光标跟随移动。
    int 0x10                
inf_loop:               ! 无限循环，系统不会停机
    jmp inf_loop
msg1:                                           ! 定义要打印的字符串，加上回车、换行长度为36。
    .byte   13,10                               ! 回车（13）、换行（10）
    .ascii  "Hello LSYSTEM"    ! 两对回车（13）、换行（10）
    .byte   13,10,13,10
.org 510                                        ! 引导扇区一共512字节。这句话表示下面语句从地址510(0x1FE)开始，所以0xAA55位于启动扇区的第510和511字节中。
boot_flag:
    .word   0xAA55                              ! 引导扇区最后两个字节必须为55和AA。因为是采用低端字节序，所有高位AA的要写在前面，就是0xAA55了。
```

操作系统通过中断实现功能，而同一个中断可以有不同功能：通过 AH 寄存器指定功能号，其他寄存器提供参数，从而实现在同一个中断下执行不同的功能，每个功能读取特定的寄存器作为参数。
int 0x10 当 ah = 0x03会读取bh寄存器的值，从而读取对应页的光标位置
int 0x10 当 ah = 0x13会显示字符串，当AL = 0x01时显示模式，所要参数：
    BH = 0：显示页码（第 0 页）。
    BL = 0x07：字符属性（白底黑字）。
    CX = 36：字符串的长度。
    ES:BP：字符串在内存中的地址。