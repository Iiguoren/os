### 进程同步与信号量
**临界区**：一次只允许一个进程进入的该进程的那一段代码。读写信号量的代码一定在临界区
一个非常重要的工作：找出进程中的临界区代码

**基本原则：互斥进入**：如果一个进程在临界区中执行，则其他进程不允许进入
* 这些进程间的约束关系成为**互斥**
* 这保证了是临界区

好的临界区保护原则：
**有空让进**：若干进程要求进入空闲临界区时，应尽快使一进程进入临界区
**优先等待**：从进程发出进入请求到允许进入，不能无限等待

### 轮换法
```c
// 进程P0
while(turn !=0);
/*临界区*/
turn = 1;
/*剩余区*/

// 进程P1
while(turn !=1);
/*临界区*/
turn = 0;
/*剩余区*/
```
满足互斥进入，
但不满足有空让进：当P0执行完退出后，虽然P1可以进入，但没有让P1直接调度进入

### 标记法
```c
flag[0]=true;
while(flag[1]);
/*临界区*/
flag[0]=false;
/*剩余区*/

flag[1]=true;
while(flag[0]);
/*临界区*/
flag[1]=false;
/*剩余区*/
```
存在死锁现象

### 结合了标记和轮转两种思想
Peterson's Algorithm（彼得森算法）
```c
//进程P0
flag[0] = true;  // 进程 P0 表示自己想进入临界区
turn = 1;        // 让出优先权给 P1
while(flag[1] && turn == 1);  // 如果 P1 也想进入，并且它的优先权更高，则等待
/* 临界区 */
flag[0] = false; // P0 退出临界区
/* 剩余区 */

//进程P1
flag[1] = true;  // 进程 P1 表示自己想进入临界区
turn = 0;        // 让出优先权给 P0
while(flag[0] && turn == 0);  // 如果 P0 也想进入，并且它的优先权更高，则等待
/* 临界区 */
flag[1] = false; // P1 退出临界区
/* 剩余区 */
```
flag[0] 和 flag[1]：
flag[i] = true 表示进程Pi想进入临界区。
flag[i] = false 表示进程Pi退出临界区。
turn：
这个变量的作用是控制优先级，让两个进程交替执行。
turn = i 表示让 P_i 先执行，即如果两个进程同时想进入临界区，就让出优先权给 i 号进程。

**互斥性分析**
（1）进入临界区
P0 想进入临界区

设置 `flag[0] = true`，表示自己想进入。
让 turn = 1，让 P1 先执行（如果它也想进）。
`while(flag[1] && turn == 1);`
如果 `flag[1] == false`（P1 没有想进），P0 直接进入临界区。
如果 `flag[1] == true`（P1 也想进），但 turn == 1，P0 需要等待，直到 P1 释放临界区。
P1 想进入临界区

设置 `flag[1] = true`，表示自己想进入。
让 turn = 0，让 P0 先执行（如果它也想进）。
`while(flag[0] && turn == 0)`;
如果 `flag[0] == false`（P0 没有想进），P1 直接进入临界区。
如果 `flag[0] == true`（P0 也想进），但 turn == 0，P1 需要等待，直到 P0 释放临界区。
（2）退出临界区
进程在退出临界区时，会将自己的 flag[i] = false，让对方有机会进入。

### 多进程--面包店算法


### 临界区保护的硬件方法
关闭中断，对于多CPU不合适，因为中断在CPU的INTR寄存器上

### 原子指令法
硬件原子指令Mutex,类似1的信号量:
```c
// 原子指令
boolean TestAndSet(boolean &x) {
    boolean rv = x; // 读取 x 的当前值
    x = true;       // 设置 x 为 true（上锁）
    return rv;      // 返回原始值
}
```
如果 lock 是 false，意味着锁是空闲的，TestAndSet(lock) 返回 false，进而成功获取锁。
如果 lock 是 true，意味着锁已被占用，TestAndSet(lock) 返回 true，进而进入循环等待（自旋）。
**TestAndSet 必须是一个原子操作**