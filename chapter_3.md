## 内存
### 定义
**页号**是虚拟地址中的一部分，表示虚拟内存中的页。虚拟内存被划分为若干个页，每个页都有一个对应的页号。
**页框号**是物理内存中实际存储页的一个标识，指代物理内存中的页框（Page Frame）。物理内存也被分为固定大小的块，这些块称为页框（Page Frame）。
### 内存使用方法
```c
.text
_entry://入口地址
    call _main
    call _exit
_main:
    ...
    ret
```
_entry 是程序的入口地址
main 和 _exit 是符号名称，_main是**入口函数**，_exit 通常是程序退出时调用的函数，它负责清理资源并正常退出程序。
汇编指令从磁盘读入内存后，先存如main入口函数地址`call base`，而main表示相对base的地址偏移量(逻辑地址)，CPU只能处理物理地址：base+offset
**解决办法**：重定位，找到一块空闲地址，将逻辑地址+空闲地址基地址base
什么时候重定位：编译时/载入时/运行时
编译时候的空闲地址执行时不一定空闲，在嵌入式系统可以在编译时候重定位
载入时的重定位程序一旦载入内存就不能动了
程序在运行时动态调整自身的内存地址，使其能够在不同地址范围内运行
base地址放在PCB中
#### **交换(swap)**
当进程睡眠时候，进程会存入磁盘的交换区中。
再次换入时候，存放的地址空间改变。
而进程交换中发生的基址变化会存放在PCB中
在运行时候重定位的程序会通过PCB中读取基址进行重定位

创建一个进程
内存找空闲内存
将基址写入PCB
写入内存
CPU取址进行

#### **分段**
实际上程序会被分成若干段：主程序，变量集，函数库，动态数组，栈
不是整个程序，式将各段分别放入内存
![alt text](pic/ch3_1.png)
具体定位：<短号， 段内偏移>mov [es:bx], ax
这时，重定位需要放每一个段的基址,此时PCB中应为段表(LDT)：
![段表](pic/ch3_2.png)

GDT+LDT表：
![alt text](image.png)
把程序分段
每个段放入内存中空闲区域
把不同段基址放入LDT
LDT赋给PCB
PC指针取址执行，根据LDT找到内存地址
### 分页分区
如何找到空间内存？
1. 固定分区：操作系统初始化时候将内存等分为k个分区
2. 可变分区：
    



分页：解决内存分区导致的内存效率问题
如果总空闲内存>160K,而没有一个空闲分区>160K，即内存碎片
将空闲分区合并，内存紧缩,但是内存紧缩时候CPU不能工作

针对每个段内存请求，系统一页一页的分配给这个段
![alt text](pic/ch3_3.png)
此时连续的段被拆分为离散的段，因此引入页表：
每个进程都有自己的页表
![alt text](pic/ch3_4.png)
`mov [0x2240], %eax`,根据页大小(4k，右移12位，16进制三位)找到页号对余值取址

### 多级页表与快表
为了提高内存空间利用率，页应该小，但是页小了页表就大了
假如内存有4G即$2^{32}$,页表大小为4K，那么页表大小为：$$2^{32}/2^{12}=1M$$，每个页表需要4M内存，如果并发十个进程就需要40M内存，导致内存浪费
而实际上大部分逻辑地址根本不会用到。所以能不能把不使用的页表去掉：
![alt text](pic/ch3_5.png)
但是如果页表中的页号并不连续，需要比较、查找($O(n)$)、折半($O(log_{2}n)$),每次方位内存都增加了时间复杂度。

**如何既要页表连续又要页表占用内存少？**
多级页表：页目录表+页表
![alt text](pic/ch3_6.png)
$2^{10}个目录项*4字节地址=4K$
上图中一级页表占了4K内存空间，其中三个二级页表已创建使用，占用了4*3=12K内存空间，其余二级页表未使用为驻留内存并不创建对应二级页表。而且每个二级页表仍为连续的
需要16K远远小于4M

多级页表增加了访存的次数，没多一级就多造成了一次访问的次数。尤其是64位系统

#### 快表
TLB是一组相联快速存储是寄存器。它存在于处理器内部，用于缓存最近访问的虚拟地址到物理地址的映射，从而减少访问页表的时间，提高地址转换的效率。
TLB的工作过程：
1. 查找虚拟地址：当处理器访问一个虚拟地址时，首先会检查该虚拟地址是否存在于TLB中（即检查快表）。如果该虚拟地址的映射已经在TLB中缓存，则可以直接从TLB获取物理地址。

2. 命中（Hit）：如果TLB中存在该虚拟地址的映射，称为TLB命中，处理器可以直接使用TLB提供的物理地址，避免了访问主存中的页表，从而提高了性能。

3. 未命中（Miss）：如果TLB中没有找到该虚拟地址的映射，称为TLB未命中，此时处理器需要访问主存中的页表，进行地址转换。完成转换后，处理器将新的映射添加到TLB中，以便以后访问。
![alt text](image-1.png)
tlb要想命中率高1.表要大，但是昂贵一般是存储64-1000作用
2.
相比$2^{10}$64很小，为什么TLB起作用？
程序的地址访问存在局部性，多体现为循环、顺序结构
   
### 段页结合
在计算机的虚拟内存管理中，当一个段（segment）放入多个页时，这些页不一定是连续的。虚拟内存的分页机制设计上允许页与页之间存在间隔，且物理内存中对应的页框（page frame）也可能不连续。
* 虚拟页与物理页的映射：在现代操作系统中，虚拟内存被划分为多个大小相同的页（通常为 4KB 或 8KB）。程序的数据、代码、堆栈等可能会跨越多个虚拟页。
* 映射到物理内存：虚拟页并不需要与物理内存中的页框（物理页）按顺序一一对应。即使虚拟页是连续的，它们在物理内存中也可以被映射到非连续的页框。操作系统使用页表来维护虚拟页和物理页框的映射关系，并且这些映射可以是非连续的。
  
因此，段在虚拟地址空间中的映射是基于页来分配内存的，而虚拟页可以跨越多个物理页框，且这些物理页框不一定是连续的。
注：CPU 在运行指令时，寻址的是虚拟内存地址，而不是物理内存地址。
**段面向用户，页面向硬件，因此不同CPU中的地址不一致**
**现代计算机的“段”一般由多个页组成，而这些页的物理地址通常是不连续的，但在虚拟地址空间上看是连续的。**

### 建立内存管理
1. 分配段、建立段表、分配页、建立页表
2. 进程带动内存使用
3. 从fork开始
* 分段
 相当于这样，第一步，先创建一个虚拟区域，然后第二步，根据这个虚拟区域来创建一个段表，第三步找到实际的物理地址空间，第四步，创建页表，第五步使用
段的分区算法，将不同段分在虚拟内存中(每个段各自连续)
将段放入虚拟内存
物理内存存入
建立页表
重定位使用内存
