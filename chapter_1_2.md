## 操作系统接口
操作系统的接口是一系列对操作系统硬件的使用函数，表现为函数调用又由系统提供，成为**系统调用**
* 连接硬件和用户
* 屏蔽细节操作
  
用户如何使用计算机？
1. 命令行
2. 图形按钮
3. 应用程序

命令是什么？命令输入后发生了什么？
**命令**:一段程序
shell也是一段程序，即/bin/sh
**shell**
```c
int main(int argc,char *argv[]){
    char cmd[20];
    while(1){
        scanf("%s", cmd);
        if(!fork())
            exec(cmd);
        else
            wait();
    }
}
fork和exec是对cpu的使用函数
scanf是对键盘的使用函数
printf是对显示器的使用函数(printf是标准库函数不是系统调用函数)
```
### 图形界面
**图形界面处理机制**：
捕捉鼠标事件中断->放入消息队列->读取消息队列->执行消息对应函数 (类似QT)

###  系统调用
**POSIX**:Portable Opeating System Interfacce of Unix
IEEE指定的一个标准族
|分类|POSIX定义|描述|
|----|----|----|
|任务管理|fork<br>execl<br>pthread_ceate|创建一个进程<br>运行一个可执行程序<br>创建一个线程|
|文件系统|open<br>EACCES<br>mode_t st_mode|打开一个文件或目录<br>返回值，表示没有权限<br>文件头结构：文件属性|

## 系统调用如何实现
### 实现一个whoami系统调用
```c
void main(){
    whoami();
}

```
* 用户程序调用whoami,一个字符串"your_hostname"放在从操作系统中(系统引导时载入)，取出来打印
* 用户程序不能随意的调用数据，不能随意jmp；(用户程序通常放在内存的高字节处，而操作系统放在低字节处，如果可以随意访问Jmp，有可能会对操作系统造成损坏)
* 系统调用可以看到root密码，可以修改它
* 系统调用可以通过显存看到别人word内容

### 为什么要区分内核态和用户态
在GDT表中存贮着特权级别，代表当前指令是用户态还是内核态。
在**内核态**中，CPU允许执行敏感的特权指令，例如直接访问硬件、管理内存页表、控制中断等。

在**用户态**中，这些操作被严格禁止。如果用户程序可以随意切换状态并执行特权指令，系统的安全性和稳定性将无法保证。

区分内核态和用户态：一种处理器"硬件设计":
    当前程序执行在什么态(哪层环)?由于CS:IP是当前指令，所以用CS的最低两位来表示：0是内核态，3是用户态